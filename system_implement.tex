\chapter{Prototype System Implementation}
\label{chp:sys_imp}

\noindent In this chapter, it will cover development implementation progress of the prototype system along with explanation and analysis. The prototype system is implemented based on system design from chapter \ref{chp:sys_design}.

\section{WebRTC APIs Implementation}

\noindent \gls{webrtc} components are accessed with JavaScript APIs. Currently in development are the Network Stream \gls{api}, which represents an audio or video data stream, and the PeerConnection \gls{api}, which allows two or more users to communicate browser-to-browser. Also under development is a DataChannel \gls{api} that enables communication of other types of data for real-time gaming, text chat, file transfer, and so forth. Because the media server used in prototype system is not support for DataChannel yet, the DataChannel \gls{api} will not be covered in this section.

\begin{figure}
	\centering
    	\includegraphics[height=0.50\textheight,natwidth=610,natheight=642]{figs/webrtc_diagram.png}
  	\caption{WebRTC two peer communication process\cite{mdn:p2pwebrtc}}
  	\label{fig:webrtc_diagram}
\end{figure}

\subsection{MediaStream API}

\par The MediaStream \gls{api} represents synchronized streams of media. For example, a stream taken from camera and microphone input has synchronized video and audio tracks. In order to obtain local media, the start step for both peers in Figure \ref{fig:webrtc_diagram} which is a communication process to set up call process from caller peer, the \gls{webrtc} \gls{api}s provide \textit{navigator.getUserMedia()} function to get the video and audio stream from user. For privacy reasons, a web application’s request for access to a user’s microphone or camera will only be granted after the browser has obtained permission from the user. Each MediaStream has an input, which might be a MediaStream generated by \textit{navigator.getUserMedia()}, and an output, which might be passed to a video element or an \textit{RTCPeerConnection}.
\par The \textit{getUserMedia()} method takes three parameters:

\begin{itemize}[topsep=-1em,parsep=0em,itemsep=0em]
 \item A constraints object.
 \item A success callback which, if called, is passed a MediaStream.
 \item A failure callback which, if called, is passed an error object.
\end{itemize}

\par The Code Snippet \ref{code:get_user_media} shows that how the prototype application implements \textit{getUserMedia()} function, it is encapsulated in \textit{WebRTCService} (service is a reusable business logic independent of views in prototype application regarding to AngularJs framework\footnote{AngularJS is an open-source web application framework, maintained by Google and community, that assists with creating single-page applications, one-page web applications that only require HTML, CSS, and JavaScript on the client side.\cite{wiki:angularjs}}).For the constraints object in parameters, the prototype application set 'audio' and 'video' value to true because it is necessary for the real-time communication application to have video and audio stream both.

\begin{lstlisting}[caption={Get User Media Stream function},label={code:get_user_media}]
var media_constraints = {audio: true,video: true};

function _setMediaStream(){
	WebRTCService.getUserMedia(media_constraints,
  								_handleUserMedia,
  								_handleUserMediaError);
  	console.log('Getting user media with constraints', 
  				media_constraints);
}
\end{lstlisting}

\par \textit{getUserMedia()} function is currently available in Chrome, Opera and Firefox. Almost all of the \gls{webrtc} \gls{api}s are slightly different based on different browsers implementation. In the Code Snippet \ref{code:webrtc_service}, from line 40 to line 103 is to make all the set up process for FireFox and from line 106 to line 175 is to make the same set up process for Google Chrome. Because \gls{webrtc} is not standard Web \gls{api} yet, so the implementation on different browsers are different and the \gls{webrtc} \gls{api}s names are slightly different in some browsers. For example, in the Code Snippet \ref{code:webrtc_service} showing, the \textit{RTCPeerConnection} \gls{api} in Firefox is \textit{mozRTCPeerConnection} but in Google Chrome it is \textit{webkitRTCPeerConnection}. In order to make the \gls{webrtc} application works on more browsers, the client side need to figure out which kind of browser is using on the machine then call the corresponding \gls{webrtc} \gls{api}s. Google provides a JavaScript shim called \textit{adapter.js}. It is maintained by Google, it abstracts away browser differences and spec changes. For Angularjs framework used by prototype application, then the \textit{WebRTCService} is implemented to be integrated with \textit{adapter.js} function to achieve the goal of compatibility.

\par However, the prototype application in this thesis will only focus on Google Chrome browser\footnote{Google Chrome is a freeware web browser developed by Google. It used the WebKit layout engine until version 27 and, with the exception of its iOS releases, from version 28 and beyond uses the WebKit fork Blink.\cite{wiki:google_chrome}} to simplify the development process because \gls{webrtc} lower level implementation on different browser s are different and hard to track the issues. Then most of the results in this thesis is based on the application performance of Google Chrome browser. The reason to choose Google Chrome browser rather than other browser because \gls{webrtc} is the technology rapidly pushed by Google and Google Chrome browser has the most market share in the world. As of March 2014, StatCounter estimates that Google Chrome has a 43\% worldwide usage share of web browsers, making it the most widely used web browser in the world.\cite{wiki:google_chrome} However, Google changes a lot to improve the performance of \gls{webrtc} on Google Chrome browser, then it makes the \gls{webrtc} \gls{api}s work different on different version of Google Chrome browser. In the Code Snippet \ref{code:webrtc_service}, from line 124 to line line 136 is the sample case to distinguish the difference among different version of Google Chrome to handle the \textit{RTCPeerConnection} \gls{ice} server constraint implementation.

\par Since \gls{webrtc} \gls{api}s is not standard \gls{api} yet, the prototype application in this thesis will not pay too much work-load on compatibility for different browsers platform. More detail about this issue will be discussed in the Chapter \ref{chp:future_work}.

\subsection{RTCPeerConnection API}

\noindent To set up peer connection, the \textit{RTCPeerConnection} \gls{api} sets up a connection between two peers. In this context, “peers” means two communication endpoints on the World Wide Web. Instead of requiring communication through a server, the communication is direct between the two entities. In the specific case of \gls{webrtc}, a peer connection is a direct media connection between two web browsers. This is particularly relevant when a multi-way communication such as a conference call is set up among three or more browsers. Each pair of browsers will require a single peer connection to join them, allowing for audio and video media to flow directly between the two peers. 

\par To establish peer connection, it requires a new \textit{RTCPeerConnection} object. The only input to the \textit{RTCPeerConnection} constructor method is a configuration object containing the information that \gls{ice}, will use to “punch holes” through intervening \gls{nat} devices and firewalls. The Code Snippet \ref{code:create_peer_connection} shows the create \textit{RTCPeerConnection} object and set three listener (\textit{onicecandidate},\textit{onaddstream},\textit{onremovestream}) to trigger the handlers to deal with the \gls{ice} candidate event and remote stream add/remove events.

\par The \textit{RTCPeerConnection} \gls{api} has two arguments to set, one is configuration object for peer connection and the other is constraint object (set transparent protocol and encryption) for peer connection, these value are shown in Code Snippet \ref{code:create_peer_connection} line 1 to line 10. In the showing case, the prototype is using \gls{stun} servers for different browser aspect, and set the \gls{rtc} channel encryption protocol to \gls{dtls}\footnote{In information technology, the Datagram Transport Layer Security (DTLS) protocol provides communications privacy for datagram protocols. DTLS allows datagram-based applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.\cite{wiki:dtls}} and enable the \gls{rtc} DataChannel.

\par Because in Firefox, \gls{webrtc} media transparent channel is only based on \gls{dtls} protocol, and in latest version Google Chrome, it is support, then in the prototype application, it will use \gls{dtls} protocol to exchange the media stream.

\par There are two \gls{api}s to handle the \textit{IceCandidate} object which contains \gls{ice} information data. One is \textit{onicecandidate} listener to trigger the function to handle the new \textit{IceCandidate} data object. The other one is \textit{addIceCandidate} function, which is shown in the Code Snippet \ref{code:add_remote_ice}, to add the new \textit{IceCandidate} data object to the remote/local peer connection session description field. 

\begin{lstlisting}[caption={Create Peer Connection function},label={code:create_peer_connection}]
pc_config = WebRTCService.webrtcDetectedBrowser() === 'firefox' ?
  			{'iceServers':[{'urls':'stun:stun.services.mozilla.com'}]} :
  			{'iceServers':[{'urls': 'stun:stun.l.google.com:19302'}]};

pc_constraints = {
			  'optional': [
			    {'DtlsSrtpKeyAgreement': true},
			    {'RtpDataChannels': true}
			  ]
			};
			
function _createPeerConnection(){

	try {
		pc = WebRTCService.peerConnection(pc_config, pc_constraints);
		pc.onicecandidate = _handleIceCandidate;
		console.log('Created RTCPeerConnnection with:\n' +
		      '  config: \'' + JSON.stringify(pc_config) + '\';\n' +
		      '  constraints: \'' + JSON.stringify(pc_constraints) + '\'.');
	} catch (e) {
		console.log('Failed to create PeerConnection, exception: ' + e.message);
		alert('Cannot create RTCPeerConnection object.');
		return;
	}
	pc.onaddstream = _handleRemoteStreamAdded;
	pc.onremovestream = _handleRemoteStreamRemoved;

}
\end{lstlisting}

\begin{lstlisting}[caption={Add Remote IceCandidate function},label={code:add_remote_ice}]
var candidate = WebRTCService.RTCIceCandidate({
					    	sdpMLineIndex:data.content.label,
					    	sdpMid:data.content.id,
					    candidate:data.content.candidate
				});
pc.addIceCandidate(candidate);

\end{lstlisting}

\par In the step 2 of Figure \ref{fig:webrtc_diagram}, after the caller \textit{RTCPeerConnection} run \textit{createOffer()} function to send offer to callee through signaling channel, the callee need run \textit{createAnswer()} function to ask the \gls{stun}/\gls{turn} server to find the path for each other peer and create the answer with \gls{sdp} content. \gls{sdp} is intended for describing multimedia communication sessions for the purposes of session announcement, session invitation, and parameter negotiation. \gls{sdp} does not deliver media itself but is used for negotiation between end points of media type, format, and all associated properties.\cite{wiki:sdp} Before \textit{RTCPeerConnection} use \textit{createOffer()} function to send a \gls{webrtc} offer to the callee, it is required to be present with local streaming video, like Figure \ref{fig:webrtc_diagram} mentioned.

\par The sample \gls{sdp} from the prototype application is shown in Code Snippet \ref{log:webrtc_answer_sdp}. Line 2 in Code Snippet \ref{log:webrtc_answer_sdp} is the field 'o', it describes originator, session identifier, username, id, version number and network address. It usually means that where this package comes from. Line 7 and line 17 are field 'm', it describes media name and transport address. And line 11,12 and line 27,28 are the relevant lines for audio and video media field, they describes media filed 'candidate' attributes, in the sample case of Code Snippet \ref{log:webrtc_answer_sdp}, they are the \gls{ice} candidate from the \gls{stun}/\gls{turn} server. These are important fields regarding to the prototype system because they are used in XMS server and application server of the prototype system.

\begin{lstlisting}[caption={Sample \gls{webrtc} Answer \gls{sdp}},label={log:webrtc_answer_sdp}]
sdp: v=0
o=xmserver 1399363527 1399363528 IN IP4 10.254.9.135
s=xmserver
c=IN IP4 10.254.9.135
t=0 0
a=ice-lite
m=audio 49152 RTP/SAVPF 0 126
a=rtpmap:0 PCMU/8000
a=sendrecv
a=rtcp:49153
a=candidate:1 1 UDP 2130706431 10.254.9.135 49152 typ host
a=candidate:1 2 UDP 2130706430 10.254.9.135 49153 typ host
...
a=acfg:1 t=1
a=rtpmap:126 telephone-event/8000
a=fmtp:126 0-15
m=video 57344 RTP/SAVPF 100
b=AS:1000
a=rtpmap:100 VP8/90000
a=fmtp:100 max-fr=30; max-fs=1200
a=sendrecv
a=rtcp:57345
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=rtcp-fb:100 goog-remb
a=candidate:2 1 UDP 2130706431 10.254.9.135 57344 typ host
a=candidate:2 2 UDP 2130706430 10.254.9.135 57345 typ host
...
\end{lstlisting}

\par In the step 3 of Figure \ref{fig:webrtc_diagram}, the caller will receive the answer from callee and process it by adding the remote \gls{sdp} to \textit{RTCPeerConnection}, like the Code Snippet \ref{code:add_remote_ice}. By the meantime, the step 4 of Figure \ref{fig:webrtc_diagram}, the callee will receive the \gls{sdp} from caller with the \gls{ice} candidate information data, and process it the same way as caller does, add some to \textit{RTCPeerConnection} object by \textit{addIceCandidate()} function.

\par \gls{webrtc} clients (known as peers) also need to ascertain and exchange local and remote audio and video media information, such as resolution and codec capabilities. Signaling to exchange media configuration information proceeds by exchanging an offer and an answer using the \gls{sdp}. The \textit{createOffer()} function and \textit{createAnswer()} function both have callback function to handle the \gls{sdp} either to call \textit{setLocalDescription()} by caller or call \textit{setRemoteDescription()} by callee when callee gets the caller's \gls{sdp} from \gls{webrtc} offer. The Code Snippet\ref{log:webrtc_answer_sdp} shown is the \gls{webrtc} answer \gls{sdp} from the callee when the callee end-point decide to accept this conversion session.

\par Once the \textit{RTCPeerConnection} is established, the client need configure where the media or data to store and display if it is necessary. In the prototype application of this thesis, media stream will be displayed in a \gls{html5} tag called \textit{<video>}. It will only be shown when there is media stream in \textit{<video>} tag source.

\section{AngularJs framework Implementation}

\noindent As it described about AngularJs in Chapter \ref{chp:pre_study}, there are three layer components in the framework, view, controller and service. The files structure is shown in Appendix \ref{code:angularjs_structure}. Application has two main pages, \textit{login} page and \textit{phone} page. There are \textit{chatboard},\textit{contacts list}, \textit{contacts table}, \textit{dialpanel} and \textit{notification} user interface component block in \textit{phone} page. For each part of the application block, it has controller Javascript file and service Javascript file. Controller and service scripts are working with the \gls{html} view scripts. In this section, there will be one sample part of the prototype application client explained to understand how the AngularJs is used in prototype application.

\par The \textit{app.js} script shown in Code Snippet \ref{code:app_js} is the bootstrap script for AngularJs framework. It initializes the application module of AngularJs framework and declare the dependencies which will be used in the application.

\par The contact table component in \textit{phone} page of the application is structured in four scripts, \textit{contactTable.jade} script in Code Snippet \ref{code:contact_table}, \textit{ContactTableDirective.js} script in Code Snippet \ref{code:contact_table_dir}, \textit{ContactsCtrl.js} script in Code Snippet \ref{code:contact_ctrl} and \textit{GoogleAPIService.js} script in Code Snippet \ref{code:google_api}. It provides the application contacts information in advanced functioning table and search function in text input filed.

\subsection{app.js Script (AngularJs Bootstrap)}

\par The \textit{app.js} script is shown in Code Snippet \ref{code:app_js}, it declares the application level module which depends on different filters, modules and services. The modules \textit{webrtcDemo.services}, \textit{webrtcDemo.controllers}, \textit{webrtcDemo.directives} and \textit{webrtcDemo.filters} are the customized modules implemented for prototype application. The rest of the module which are included as dependencies are third party AngularJs modules used in the prototype application. AngularJs developer community is quite active community, there are many useful open sourced projects or modules can be just included like the line 6 to line 15 in Code Snippet \ref{code:app_js}.

\par From line 22 to line 41 is the configuration for the application level module \textit{webrtcDemo}, in the prototype application code, it used to set the application routing map. There are two main pages, one is \textit{login} page with "/login" \gls{url}(line 24,25) and the other one is \textit{phone} page with "/chat" \gls{url}(line 28,29). The Angular controllers which are bind with these page view are also declared in \textit{\$routeProvider} service in line 26 and line 30. And the default \gls{url} is set to "/login" to make sure if user has not logged in the system, he need to input the user credential to log himself.

\par From line 43 to line 49 in the Code Snippet \ref{code:app_js} are the modules declaration part for four different customized modules used in application. 

\subsection{contactTable.jade Script (View)}

\par The \textit{contactTable.jade} script is the view component of the AngularJs. It is a Jade\footnote{Jade is a high performance template engine heavily influenced by Haml and implemented with JavaScript for node.\cite{github:jade}} script file. The template engine used on Node.js in prototype application is Jade which provides more clear way to program \gls{html} node template scripts. In the Code Snippet \ref{code:contact_table}, Jade has the same node name as normal node template engine \gls{ejs} and some Angular directives in the template. For example, at line 2 in Code Snippet \ref{code:contact_table}, the \textit{angucomplete-alt} directive is a third party Angular directive to provide auto-completion features in \gls{html} \textit{<input>} text tag. The different attributes in the \textit{angucomplete-alt} node is to set some configuration to this directive, like the attribute files \textit{local-data} is the array data to search for content as auto-complete reference.

\par Moreover, AngularJs itself provides native Angular directive as well. For instance, at line 17 in Code Snippet \ref{code:contact_table}, the attribute \textit{ng-class} is a native Angular directive attribute, it provides the \gls{css}\footnote{Cascading Style Sheets (CSS) is a style sheet language used for describing the look and formatting of a document written in a markup language.\cite{wiki:css}} change to some specific \gls{css} class name when some certain value matches in AngularJs expression. At line 17, the \textit{<tr>} tag's \gls{css} attributes will be success class only if the boolean value of \textit{item.online} is \textit{true}.

\par AngularJs provides two-way data module binding in the template and controller. Line 63 in the Code Snippet \ref{code:contact_table}, \textit{\{\{item.number\}\}} is the Angular template to display the \textit{number} property value of \textit{item} object in the \gls{html} template. And line 21 is the example of Angular template integrated with Angular filter, the third-party filter \textit{iif} here is the filter to check the \textit{\{\{item.online\}\}} value if it is \textit{true} or \textit{false}. If it is \textit{true} then it will show \textit{Online} string text in the \gls{html} template otherwise it will show \textit{Offline} string text. The syntax here is quite similar to any other programming language.

\subsection{ContactTableDirective.js Script (Customized Directive)}

\par After creating the view of contact table component, it is necessary to make a customized directive to bind controller to the view. It is called \textit{Directive} in AngularJs, the \textit{ContactTableDirective.js} script is shown in Code Snippet \ref{code:contact_table_dir}. From line 10 to line 20 is the directive declaration, it sets the \textit{templateUrl} to 'partials/contactTable' which is the view component of contact table file path and binds the controller which name \textit{ContactsCtrl} to the view component. The \textit{restrict} filed in the directive is to set the template type for \textit{ContactTableDirective}, in the Code Snippet \ref{code:contact_table_dir} line 13, it means this directive is a \gls{html} element template, it can be used as normal \gls{html} element by using name 'contact-table'.

\par From line 22 to line 27 is the Angular filter declaration, there is one filter name \textit{iif}, the only function it does is to check the \textit{input} value and return \textit{trueValue} if \textit{input} is \textit{true} otherwise return \textit{falseValue}. The usage is described in previous section in line 21 of the Code Snippet \ref{code:contact_table}.

\subsection{ContactsCtrl.js Script (Controller)}

\par The controller in AngularJs is to control the user interface logic and bridge the data business logic from the services to the user interface views. The example controller in Code Snippet \ref{code:contact_ctrl} controls the contactTable view directive and get data from GoogleAPIService. In the line 10 of Code Snippet \ref{code:contact_ctrl}, in the controller construction function, there are several services arguments. They are the services this controller will use in the application, one of them is \textit{GoogleAPIService} which is related to the contacts information data. The contactTable view directive need contacts information data to show in the \gls{html} template. And \textit{storage} is another service provides \\textit{localstorage} function in \gls{html5} application. This service is used to store the contacts information data locally to make user no need to import his Google contacts information all the time. This function is implemented at line 82 of the Code Snippet \ref{code:contact_ctrl}.

\par At line 56 of the Code Snippet \ref{code:contact_ctrl}, it is the function \textit{\$scope.importContacts}, the reason this function is under \textit{\$scope} object is because this function is directly triggered by one \gls{ui} button. In this function, there are two Javascript promise function from the \textit{GoogleAPIService}. One is \textit{GoogleAPIService.oAuth()} function which is to ask user to get Google \gls{api} permission to query the Google Contacts \gls{api}. The other one is after get the Google \gls{api} permission to query the contacts information data by Google Contacts \gls{api}.

\par \textit{Promise} object is the new concept in the Javascript and AngularJs. The core idea behind promises is that a promise represents the result of an asynchronous operation. A promise is in one of three different states:\cite{website:promise}
\begin{itemize}[topsep=-1em,parsep=0em,itemsep=0em]
 \item \textbf{Pending} - The initial state of a promise.
 \item \textbf{Fulfilled} - The state of a promise representing a successful operation.
 \item \textbf{Rejected} - The state of a promise representing a failed operation.
\end{itemize}
It is the very cool concept in the AngularJs. Since everything in Javascript is asynchronous operation, then promise object function is used to deal with the function calling after previous asynchronous operation success. The implementation of these two promise functions will be covered in the next section.

\par From line 60 to line 78 is the process to filter out the useful information from the response data to get the correct contact information into \textit{contact} object, then push them one by one into a \textit{contact} object array in order to be used by contact table view component.

\subsection{GoogleAPIService.js Script (Service)}

\par 

\section{Socket.IO Implementation}

\section{SIP Implementation on Application Server}

\section{XMS Media Server Integration on Application Server}

\section{Advanced Communication Function Implementation}

\subsection{SMS Messaging}

\subsection{Files Sharing}

\subsection{Google Contacts Import}