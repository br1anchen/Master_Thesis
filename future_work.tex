\chapter{Future Work}
\label{chp:future_work}

\noindent In this Chapter, there are some future improvement for the prototype system will be discussed. And some future research direction of \gls{webrtc} integrated with traditional telephony network will be include as well.

\section{RTCDataChannel usage}

\par Because the XMS media server handles all the media stream exchange between the end point clients and it is not support \textit{RTCDataChannel}, the prototype application does not implement \textit{RTCDataChannel} usage in the system. Current using Delivery.js library is good at bidirectional file sharing between clients and server through WebSocket. But is has some disadvantages still. The most apparent disadvantage would be the fact that it bypasses traditional caching methods. Instead of caching based on a file’s URL, caching would be based on the content of the Web Socket’s message. One possibility would be to cache a base64, or text, version of the file within Redis\footnote{Redis is an open-source, networked, in-memory, key-value data store with optional durability. It is written in ANSI C.\cite{wiki:redis}} for fast, in memory, access. And also the sharing files are uploaded to the server then push back to the other clients, it takes longer time to finish this process than peer to peer sharing files. And also in current prototype system, the shared files will be temporary pre-stored for the client, it will cause some problem when the sharing file is very big in size and it will take over all the memory resource the client has.

\par One obvious solution will be implementing the \textit{RTCDataChannel} \gls{api} on each connected client and create new \textit{RTCPeerConnection} for each pair user in mesh network for only sharing files purpose. Since these new \textit{RTCPeerConnection}
is not necessary active during the whole time of application using, they are possible to remove after it is used for sharing files to release more memory recourse for browser clients.

\par The other solution will be using third party peer to peer sharing services, such as Sharefest\footnote{One-To-Many sharing application. Serverless. Eliminates the need to fully upload your file to services such as Dropbox or Google Drive. Put your file and start sharing immediately with anyone that enters the page. Pure javascript-based. No plugins needed thanks to HTML5 WebRTC Data Channel API}. It operates on a mesh network similar to Bit-torrent network. The main difference is that currently the peers are coordinated using an intelligent server. This coordinator controls which parts are sent from A to B and who shall talk with whom. Peer5(\url{http://peer5.com/}) Coordinator (or any other solution) is used to accomplish this. Each peer will connect to few other peers in order to maximize the distribution of the file.\cite{github:sharefest} In this case the client will still keep having single \textit{RTCPeerConnection} with the \textit{RTCDataChannel} on the client, it will fit the work scenario of the prototype system.

\section{Browser Compatibility}

\par The prototype system is developed on single browser (Google Chrome), it is not tested on other browser. The main reason is that the bug fixing for cross browser platform on \gls{webrtc} is too complicated. Since \gls{webrtc} is not standard Web \gls{api} yet, all the browsers have their own implementation. Although most of the \gls{webrtc} \gls{api} calling in the application layer are more or less the same, the issues happen in different ways and they are hard to debug.

\par Fortunately, Google provides the \textit{adapter.js} script for developer to solve the cross platform issue on Google Chrome and Firefox. It is implemented in WebRTCService in prototype application client shown in Code Snippet \ref{code:webrtc_service}. During the test, it still happens some compatibility issues between Google Chrome and Firefox. Current version of prototype system is working fine on both Google Chrome and Firefox browser. However, there are some problem when call is made from Firefox to Google Chrome. The main reason for that, it is the \gls{sdp} content generated on both platform is not compatible in this work scenario. This issue need to be fixed in the future work.

\section{Media Server Performance}

\par During the test of the prototype system, the XMS media server performance is quite concerned in the work scenario. The main reason is that the current XMS media server host on a normal laptop machine, it is not powerful enough for high traffic load of the media stream exchange.

\par The solution for that, it would be easy to host the media server on another powerful server machine. Considering the purpose of the prototype system is to build a system integrated with \gls{webrtc} and \gls{voip} network, it is not good solution to keep updating the XMS media server machine. There will be two way to solve this issue in real time communication work scenario. One is to host XMS media server on the third party cloud service, like \gls{aws} \gls{ec2} instance. Because the third party service will handle the performance, it will rarely have the problem on performance issue. However, this solution is quite expensive when huge number of users make large amount of media stream traffic to the XMS media server. The other solution will be distribute multiple XMS media server to share the traffic load in the prototype system. Then it will be easy to control the performance of the media server but it will cost more physical machine expense.

\par As a result, the performance of the media server need to be considered as the cost of media server deployment and distribution together.

\section{Object RTC (ORTC) API for WebRTC}

\par \gls{ortc} is a free, open project that enables mobile endpoints to talk to servers and web browsers with \gls{rtc} capabilities via native and simple Javascript APIs. The Object RTC components are being optimized to best serve this purpose.\cite{website:ortc} The mission of \gls{ortc} is to enable rich, high quality, RTC applications to be developed in mobile endpoints and servers via native toolkits, simple Javascript APIs and HTML5. It is also a mandate that Object RTC be compatible with WebRTC.

\par Current WebRTC client is made for browser only, only the smart phone with supported mobile web browser can use these application. According to \gls{ortc}, it is possible to make all the smart phone as a \gls{webrtc} client. Then there will be no more different signaling implementation because both end point use \gls{webrtc} \gls{sdp} content and \gls{webrtc} mechanism. Only one signaling mechanism need to be implemented in this way, it will make less compatibility problem for different types end pints.

\par There is a related open source project, ortc-lib (\url{https://github.com/openpeer/ortc-lib}), it is \gls{ortc} C++ library wrapper for \gls{webrtc}.This \gls{sdk} library implementation of the \gls{ortc} specification that will enable mobile end points to talk to a \gls{webrtc} enabled browser.

\par If we look at the success of apps like Whatsapp\footnote{WhatsApp Messenger is a proprietary, cross-platform instant messaging subscription service for smartphones that uses the internet for communication. In addition to text messaging, users can send each other images, video, and audio media messages as well as their location using integrated mapping features.} , Tango\footnote{Tango is third-party, cross platform messaging application software for smartphones developed by TangoME, Inc.} , Viber\footnote{Viber is a proprietary cross-platform instant messaging voice-over-Internet Protocol application for smartphones developed by Viber Media.}, Voxer\footnote{Voxer is a San Francisco based mobile app development company most well known for its free Voxer Walkie Talkie app for smartphones.}, Facebook Messenger\footnote{Facebook Messenger is an instant messaging service and software application which provides text and voice communication. Integrated with Facebook's web-based Chat feature and built on the open MQTT protocol,Messenger lets Facebook users chat with friends both on mobile and on the main website.} etc these are all \gls{ott} applications that have already won in mobile communications. Placing a phone call, is nearly the last thing a teen or twenty-something user is looking to do with their phone nowadays.\cite{web:ott_com} If the concept of \gls{ortc} has been widely spread and implemented, \gls{webrtc} and \gls{ortc} will become the next generation telecommunication network.

\section{Advanced function for telecommunication}

\par Since the prototype system bridges the web network and telecommunication network, it is easy to think about how to implement powerful web technology with the telephony use case. For example real time translation in speaking. Translator.js is a JavaScript library built top on Google Speech-Recognition \& Translation API to transcript and translate voice and text. It supports many locales and brings globalization in \gls{webrtc}.\cite{github:translatorjs} It uses Google Speech-Recognition \gls{api} to convert user spoken sentence into text string, then uses Google's Non-Official Translation \gls{api} to translate the text into target language text and use \textit{meSpeak.js} library to play text using a robot voice.

\par With the social network information, it is easy to get the person profile information of the current conversation user. It is possible to visualize the social network topological diagram to show what is the relationship between two speaking user in the conversation. For the business conference using, it is possible to know the person information and company background information during the conference.

\par Furthermore, with the voice recognition on the web, it is possible to make any useful command through the video/audio conference. For example, one of users want other people to send an E-mail with some attachments to him and mentioned it during the conversation. Then the other user's application will recognize the command and generate the E-mail content at the same time and add the files from the computer as attachments. It will make the normal conference meeting more efficient and less misunderstanding and better for reminding.

