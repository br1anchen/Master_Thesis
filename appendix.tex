\appendix
\addtocontents{toc}{%
  \protect\vspace{1em}% 
  \protect\noindent \bfseries \appendixtocname\protect\par
  \protect\vspace{-.5em}%
 }
 \renewcommand{\chaptername}{\appendixname}
 
\begin{appendices}

\chapter{Appendix A}

\section{Application Script} \label{app:app_js}
\begin{lstlisting}[caption={app.js in application client},label={code:app_js}]
'use strict';

// Declare app level module which depends on filters, and services

angular.module('webrtcDemo', [
  'ui.bootstrap',
  'btford.socket-io',
  'angularLocalStorage',
  'angular-underscore',
  'ngRoute',
  'ui.keypress',
  'angularMoment',
  'angularFileUpload',
  'angular-table',
  'angucomplete-alt',
  'webrtcDemo.services.values',
  'webrtcDemo.services',
  'webrtcDemo.controllers',
  'webrtcDemo.directives',
  'webrtcDemo.filters'
]).
config(function ($routeProvider, $locationProvider, $httpProvider) {
  $routeProvider.
    when('/chat', {
      templateUrl: 'partials/phoneView',
      controller: 'PhoneViewCtrl'
    }).
    when('/login',{
      templateUrl: 'partials/login',
      controller: 'LoginViewCtrl'
    }).
    otherwise({
      redirectTo: '/login'
    });

  $locationProvider.html5Mode(true);

  $httpProvider.defaults.useXdomain = true;
  delete $httpProvider.defaults.headers.common['X-Requested-With'];
  $httpProvider.defaults.withCredentials = true;
});

angular.module('webrtcDemo.services', ['webrtcDemo.services.values']);

angular.module('webrtcDemo.controllers',['webrtcDemo.services.values']);

angular.module('webrtcDemo.directives',['webrtcDemo.services.values']);

angular.module('webrtcDemo.filters',['webrtcDemo.services.values']);
\end{lstlisting}

\section{WebRTCService Script} \label{app:webrtc_service}

\begin{lstlisting}[caption={WebRTCService.js in application client},label={code:webrtc_service}]
'use strict';

/**
*  services Module
*
* WebRTCService with browser adapter.js function
*/

angular.module('webrtcDemo.services').
	factory('WebRTCService',function () {
		var _ws;//websocket obj
		
		var _RTCPeerConnection;
		var _RTCSessionDescription;
		var _RTCIceCandidate;
		var _getUserMedia;
		var _createIceServer;
		var _attachMediaStream;
		var _reattachMediaStream;
		var _webrtcDetectedBrowser;
		var _webrtcDetectedVersion;

		function _initWebRTC () {
			_RTCPeerConnection = null;
			_RTCSessionDescription = null;
			_RTCIceCandidate = null;
			_getUserMedia = null;
			_createIceServer = null;
			_attachMediaStream = null;
			_reattachMediaStream = null;
			_webrtcDetectedBrowser = null;
			_webrtcDetectedVersion = null;

			_setRTCElement();
		}

		function _setRTCElement() {

			if(navigator.mozGetUserMedia){
				console.log("This appears to be Firefox");

				_webrtcDetectedBrowser = "firefox";
				_webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);

				_RTCPeerConnection = mozRTCPeerConnection;
				_RTCSessionDescription = mozRTCSessionDescription;
  			_RTCIceCandidate = mozRTCIceCandidate;
  			_getUserMedia = navigator.mozGetUserMedia.bind(navigator);

  			// Creates iceServer from the url for FF.
			  _createIceServer = function(url, username, password) {
			    var iceServer = null;
			    var url_parts = url.split(':');
			    if (url_parts[0].indexOf('stun') === 0) {
			      // Create iceServer with stun url.
			      iceServer = { 'url': url };
			    } else if (url_parts[0].indexOf('turn') === 0) {
			      if (_webrtcDetectedVersion < 27) {
			        // Create iceServer with turn url.
			        // Ignore the transport parameter from TURN url for FF version <=27.
			        var turn_url_parts = url.split("?");
			        // Return null for createIceServer if transport=tcp.
			        if (turn_url_parts.length === 1 ||
			            turn_url_parts[1].indexOf('transport=udp') === 0) {
			          iceServer = { 'url': turn_url_parts[0],
			                        'credential': password,
			                        'username': username };
			        }
			      } else {
			        // FF 27 and above supports transport parameters in TURN url,
			        // So passing in the full url to create iceServer.
			        iceServer = { 'url': url,
			                      'credential': password,
			                      'username': username };
			      }
			    }
			    return iceServer;
			  };

  			_attachMediaStream = function(element, stream) {
			    console.log("Attaching media stream");
			    element.mozSrcObject = stream;
			    element.play();
			  };

			  _reattachMediaStream = function(to, from) {
			    console.log("Reattaching media stream");
			    to.mozSrcObject = from.mozSrcObject;
			    to.play();
			  };

			  // Fake get{Video,Audio}Tracks
			  if (!MediaStream.prototype.getVideoTracks) {
			    MediaStream.prototype.getVideoTracks = function() {
			      return [];
			    };
			  }

			  if (!MediaStream.prototype.getAudioTracks) {
			    MediaStream.prototype.getAudioTracks = function() {
			      return [];
			    };
			  }

			}else if(navigator.webkitGetUserMedia){
				console.log("This appears to be Chrome");

				_webrtcDetectedBrowser = "chrome";
				_webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);

			  _RTCPeerConnection = webkitRTCPeerConnection;
			  _RTCSessionDescription = RTCSessionDescription;
			  _RTCIceCandidate = RTCIceCandidate;
			  _getUserMedia = navigator.webkitGetUserMedia.bind(navigator);

			  // Creates iceServer from the url for Chrome.
			  _createIceServer = function(url, username, password) {
			    var iceServer = null;
			    var url_parts = url.split(':');
			    if (url_parts[0].indexOf('stun') === 0) {
			      // Create iceServer with stun url.
			      iceServer = { 'url': url };
			    } else if (url_parts[0].indexOf('turn') === 0) {
			      if (_webrtcDetectedVersion < 28) {
			        // For pre-M28 chrome versions use old TURN format.
			        var url_turn_parts = url.split("turn:");
			        iceServer = { 'url': 'turn:' + username + '@' + url_turn_parts[1],
			                      'credential': password };
			      } else {
			        // For Chrome M28 & above use new TURN format.
			        iceServer = { 'url': url,
			                      'credential': password,
			                      'username': username };
			      }
			    }
			    return iceServer;
			  };

			  // Attach a media stream to an element.
			  _attachMediaStream = function(element, stream) {
			    if (typeof element.srcObject !== 'undefined') {
			      element.srcObject = stream;
			    } else if (typeof element.mozSrcObject !== 'undefined') {
			      element.mozSrcObject = stream;
			    } else if (typeof element.src !== 'undefined') {
			      element.src = URL.createObjectURL(stream);
			    } else {
			      console.log('Error attaching stream to element.');
			    }
			  };

			  _reattachMediaStream = function(to, from) {
			    to.src = from.src;
			  };

			  // The representation of tracks in a stream is changed in M26
			  // Unify them for earlier Chrome versions in the coexisting period
			  if (!webkitMediaStream.prototype.getVideoTracks) {
			    webkitMediaStream.prototype.getVideoTracks = function() {
			      return this.videoTracks;
			    };
			    webkitMediaStream.prototype.getAudioTracks = function() {
			      return this.audioTracks;
			    };
			  }

			  // New syntax of getXXXStreams method in M26
			  if (!webkitRTCPeerConnection.prototype.getLocalStreams) {
			    webkitRTCPeerConnection.prototype.getLocalStreams = function() {
			      return this.localStreams;
			    };
			    webkitRTCPeerConnection.prototype.getRemoteStreams = function() {
			      return this.remoteStreams;
			    };
			  }

			}else{
				console.log("Browser does not appear to be WebRTC-capable");
			}

		}

		return {
			init : function (socket) {
				if(socket){
					//init service with websocket
					_ws = socket;
				}

				_initWebRTC();

			},

			peerConnection : function(config,constraints){
				if(_RTCPeerConnection){
					return new _RTCPeerConnection(config,constraints);
				}
				return null;
			},

			RTCSessionDescription : function(message){
				if(_RTCSessionDescription){
					return new _RTCSessionDescription(message);
				}
				return null;
			},

			RTCIceCandidate : function(options){
				if(_RTCIceCandidate){
						return new _RTCIceCandidate(options);
					}
					return null;
			},

			webrtcDetectedBrowser : function(){
				return _webrtcDetectedBrowser;
			},

			attachMediaStream : function(element, stream){
				return _attachMediaStream(element, stream);
			},

			reattachMediaStream : function(to, from){
				return _reattachMediaStream(to, from);
			},

			getUserMedia : function(constraints, handleUserMedia, handleUserMediaError){
				return _getUserMedia(constraints, handleUserMedia, handleUserMediaError);
			}

		}
	});	
	
\end{lstlisting}

\section{ContactTable Scripts} \label{app:contact_table}

\begin{lstlisting}[caption={contactTable.jade in application client},label={code:contact_table}]
div(id = "contactTable")
	angucomplete-alt(id="contactSearch",
		place-holder="Search Contact Name",
		pause="100",
		selected-object="selectedContact",
		local-data="contactsHolder.contacts",
		search-fields="name",
		title-field="name",
		description-field="number"
	  minlength="1",
	  input-class="form-control form-control-small")
	tabset
		tab(heading = "Conacts")
			table(id = "contacts", at-table, at-paginated, at-list="contactsHolder.contacts | orderBy:online", at-config="config",class="table table-hover table-striped table-condensed" )
				thead
				tbody
					tr(ng-class = "{success: item.online}", ng-init = "item.hvor = false", ng-mouseenter = "contactHvor(item)", ng-mouseleave = "contactHvor(item)")
						td(at-implicit, at-sortable, at-attribute="name", width="250")
						td(at-sortable, at-attribute="online", at-title="Status", width="200", at-initial-sorting="desc")
							p(ng-hide = "item.hvor").
								{{item.online | iif : "Online" : "Offline" }}
							div(class="btn-group contactCallBtn", ng-show = "item.hvor")
								button(type="button", class="btn btn-success", ng-click = "callContact(item)").
									{{item.online | iif: "Video Call" : "Call"}}
								button(type="button", class="btn btn-success dropdown-toggle", data-toggle="dropdown")
									span(class="caret")
								ul(class="dropdown-menu", role="menu")
									li
										a(ng-click="") Instance Message
									li
										a(ng-click="") SMS
									li(class="divider")
									li
										a(ng-click="") Edit Contact...
						td(at-title="Description")
							p
								| Telephone : {{item.number}}
			at-pagination(at-list="contactsHolder.contacts" at-config="config")
		tab(heading = "Online")
			table(id = "onlines", at-table, at-paginated, at-list="onlines", at-config="config", class="table table-hover table-striped table-condensed")
				thead
				tbody
					tr(ng-init = "item.hvor = false", ng-mouseenter = "contactHvor(item)", ng-mouseleave = "contactHvor(item)")
						td(at-implicit, at-sortable, at-attribute="name", width="250", at-initial-sorting="asc")
						td(at-title="Status", width="200")
							p(ng-hide = "item.hvor").
								{{item.online | iif : "Online" : "Offline" }}
							div(class="btn-group contactCallBtn", ng-show = "item.hvor")
								button(type="button", class="btn btn-success", ng-click = "callContact(item)").
									{{item.online | iif: "Video Call" : "Call"}}
								button(type="button", class="btn btn-success dropdown-toggle", data-toggle="dropdown")
									span(class="caret")
								ul(class="dropdown-menu", role="menu")
									li
										a(ng-click="") Instance Message
									li
										a(ng-click="") SMS
									li(class="divider")
									li
										a(ng-click="") Edit Contact...
						td(at-title="Description")
							p
								| Telephone : {{item.number}}
			at-pagination(at-list="onlines" at-config="config")
\end{lstlisting}

\begin{lstlisting}[caption={ContactTableDirective.js in application client},label={code:contact_table_dir}]
'use strict';


/**
*  Directives Module
*
* Contact Table Directive
*/
angular.module('webrtcDemo.directives').
	directive('contactTable',function () {

		return{
			restrict: 'E',
			replace: true,
			scope: true,
			templateUrl: 'partials/contactTable',
			controller: 'ContactsCtrl'
		};

	});

angular.module('webrtcDemo.filters').
	filter('iif', function () {
   return function(input, trueValue, falseValue) {
        return input ? trueValue : falseValue;
  };
});
\end{lstlisting}

\section{ContactsCtrl Script} \label{app:contact_ctrl}

\begin{lstlisting}[caption={ContactsCtrl.js in application client},label={code:contact_ctrl}]
'use strict';


/**
*  Controllers Module
*
* Contacts Controller
*/
angular.module('webrtcDemo.controllers').
	controller('ContactsCtrl',function ($scope,$location,WebSocketService,GoogleAPIService,storage,$filter) {
		console.log('init contacts controller');

		$scope.selectedContact;

		var username = storage.get('current-user').name;
		_initContactsView();

		function _initContactsView(){

			$scope.$watch('selectedContact',function(newVal,oldVal){
				if(newVal && newVal != oldVal){
					console.log($scope.selectedContact);
					$scope.outPhone.number = $scope.selectedContact.originalObject.number;
				}
			});

			if(storage.get('contactList-' + username)){
				$scope.contactsHolder.contacts = storage.get('contactList-' + username);
			}

			_initContactsTable();
		}

		function _initContactsTable(){

			$scope.config = {
		    itemsPerPage: 13,
		    fillLastPage: "yes"
		  };
		}

		$scope.callContact = function(contact){
			console.log('pick number: ' + contact.number);
			$scope.outPhone.number = contact.number;
			$scope.callNumber();
		}

		$scope.contactHvor = function(contact){
			contact.hvor = ! contact.hvor;
		}

		$scope.contactListHvor = function(contact){
			contact.listHvor = ! contact.listHvor;
		}

		$scope.importContacts = function(){
			$scope.contactsHolder.contacts = [];
			GoogleAPIService.oAuth().then(function(token){
				GoogleAPIService.queryContacts(token).then(function(data){
					angular.forEach(data.feed.entry,function(person, key){
						if(person['gd$phoneNumber']){
							var contact = {
								name: person.title['$t'],
								number: person['gd$phoneNumber'][0]['$t'],
								online: false
							}

							if($scope.onlines){
								var online = _.find($scope.onlines, function(c){
									return c.number == contact.number; 
								});

								if(online){
									contact.online = true;
								}
							}

							$scope.contactsHolder.contacts.push(contact);
						}
					});

					storage.set('contactList-' + username,$scope.contactsHolder.contacts);

				});
			});
		}

	});
\end{lstlisting}

\section{GoogleAPIService Script} \label{app:google_api}

\begin{lstlisting}[caption={GoogleAPIService.js in application client},label={code:google_api}]
'use strict';



/**
*  services Module
*
*  Google API Service
*/

angular.module('webrtcDemo.services').
	factory('GoogleAPIService', function ($q,$http,storage) {

		function _authLogin(){
			var deferred = $q.defer();

			var config = {
		      'client_id': 'xxxxxxxxxxxxxxx.apps.googleusercontent.com',
		      'scope': 'https://www.google.com/m8/feeds'
		    };
	    gapi.auth.authorize(config, function() {

	      console.log('login complete');
	      console.log(gapi.auth.getToken());
	      deferred.resolve(gapi.auth.getToken());

	    });

	    return deferred.promise;
		}

		function _fetchContacts(authToken){
			var deferred = $q.defer();

			var url = 'https://www.google.com/m8/feeds/contacts/default/full?access_token=' + authToken.access_token + '&alt=json&max-results=500&callback=JSON_CALLBACK';

			$http.jsonp(url).
	    success(function(data, status, headers, config) {
	      deferred.resolve(data);
	    }).
	    error(function(data, status, headers, config) {
	      deferred.reject('GoogleAPIService:queryContacts:Failed');
	    });

			return deferred.promise;
		}

		return{
			
			oAuth: function(){

				return _authLogin();
			
			},

			queryContacts: function(authToken){

				return _fetchContacts(authToken);

			}

		}

	});
\end{lstlisting}

\section{PhoneViewCtrl Script}

\begin{lstlisting}[caption={\_setSocketListener() Function in PhoneViewCtrl.js on Application Client},label={code:client_socket}]
function _setSocketListener(socket){

			socket.on('log', function (array){
			  console.log.apply(console, array);
			});

			socket.on('webrtc', function (data){
			  console.log('Received webrtc message:', data);
			  switch(data.type){
			  	case 'register':
				  	if(data.msg == 'success'){
				  		offer2xms = false;
				  		if(data.colleagues.length != 0){
				  			_.map(data.colleagues,function(c){
				  				var contact = _.find($scope.contactsHolder.contacts,function(contact){
				  					return contact.number == c.number;
				  				});
				  				if(contact){
				  					contact.online = true;
				  					$scope.onlines.push(contact);
				  				}
				  			});
				  		}
							_maybeStart();
				  	}
			  		break;
			  	case 'online':
			  		$scope.contactsHolder.contacts = _.map($scope.contactsHolder.contacts,function(c){
			  			if(c.number == data.user.number){
			  				c.online = true;
			  				$scope.onlines.push(c);
			  			}
			  			return c;
			  		})
			  		break;
			  	case 'join conference':

			  		break;
			  	case 'disconnect':
			  		$scope.contactsHolder.contacts = _.map($scope.contactsHolder.contacts,function(c){
			  			if(c.number == data.user.number){
			  				c.online = false;
			  				var i = $scope.onlines.indexOf(c);
					      if(i != -1) {
					        $scope.onlines.splice(i, 1);
					      }
			  				//$scope.onlines.pop(c);
			  			}
			  			return c;
			  		})
			  		break;
			  	case 'offer':
			  		/*
			  		if (!isStarted) {
				      _maybeStart();
				    }
				    pc.setRemoteDescription(WebRTCService.RTCSessionDescription(data));
				    _doAnswer();
				    */
			  		break;
			  	case 'answer':
			  		if(isStarted){
			  			if(data.sdp){
			  				pc.setRemoteDescription(WebRTCService.RTCSessionDescription(data));
			  			}
			  			if(!data.self){
			  				socket.emit('sip',{
						    	type: 'invite',
						    	username: $scope.user.name,
						    	content: {
						    		to: $scope.outPhone.number
						    	}
						    });
			  			}else{
			  				var channel;
			  				if(callDirection === 'outbound'){
			  					channel = 'sip';
			  				}else{
			  					channel = 'webrtc';
			  				}
			  				
			  				socket.emit(channel,{
						    	type: 'answerInvite',
						    	username: $scope.user.name,
						    	conf_id: conf_id
						    });

						    //show answer process notification
								$rootScope.$broadcast('answer-call',{number : $scope.toAnswerPhone.number});

			  			}
					    
			  		}
			  		break;
			  	case 'candidate':
			  		/*
			  		if(isStarted){
			  			var candidate = WebRTCService.RTCIceCandidate({
					    	sdpMLineIndex:data.content.label,
					    	sdpMid:data.content.id,
					      candidate:data.content.candidate
					    });
					    pc.addIceCandidate(candidate);
			  		}
			  		*/
			  		break;
			  	case 'bye':
			  		if(isStarted){
			  			_handleRemoteHangup();
			  		}
			  		break;
			  	case 'createRTCoffer':
						callDirection = data.callDirection;
						conf_id = data.conf_id;
						break;
			  	default:
			  		break;
			  }
			});

			socket.on('sip',function(data){
				console.log('Received sip message:',data);
				switch(data.type){
					case 'createRTCoffer':
						callDirection = data.callDirection;
						break;
					case 'busy':

			  		break;
					default:
						break;
				}
			});
		}

\end{lstlisting}

\chapter{Appendix B}

\section{Socket.IO Script} \label{server:socket}

\begin{lstlisting}[caption={socket.js on Application Server},label={code:server_socket}]
SocketManager.prototype.listen = function(server){
  var self = this;
  clients = {};
  sipClients = {};
  callRequests = {};
  conversations = {};

  io = socketio.listen(server);

  io.sockets.on('connection', _handlerSocket);

  _handlerSip();
}

function _handlerSocket(socket) {
  var delivery = dl.listen(socket);

  // convenience function to log server messages on the client
  function log(){
    var array = [">>>"];
    for (var i = 0; i < arguments.length; i++) {
      array.push(arguments[i]);
    }
      socket.emit('log', array);
  }

  socket.on('sip',function (data){
    log('Got sip message:', data);

    switch(data.type){
      case 'register':
        if(data.username != ""){
          gw.register(data.content.browserClient,function(result){
            socket.emit('sip',result);
          });
        }
        break;
      case 'invite':
        var callerClient = clients[data.username];
        var calleeClient = clients[data.content.to];

        if(!callerClient.inConference){
          xmsManager.createConference({
            type: "audiovideo",
            max_p: 9,
            reserve: 0,
            layout: 0,
            caption: "yes"
          },function(conf_id){
            callerClient.conf_id = conf_id;
            conversations[conf_id] = _createConversation(conf_id);

            xmsManager.joinConference(callerClient.local_identifier,conf_id,{
              caption: "webrtc: " + data.username,
              region: 0,
              audio: "sendrecv",
              video: "sendrecv"
            },function(connected){
              console.log(data.username + ' joined conference : ' + connected);
              callerClient.inConference = true;
              conversations[conf_id].inboundContacts.push(data.username);
              socket.join(conf_id.toString());
            });

            if(calleeClient){
              callerClient.socket.emit('webrtc',{
                type: "ringing",
                number: calleeClient.number
              });

              calleeClient.callreq_id = callerClient.callreq_id;
              callRequests[callerClient.callreq_id].callee = calleeClient;

              calleeClient.socket.emit('webrtc',{
                type: "createRTCoffer",
                inComingNumber: data.username,
                callDirection: 'inbound',
                conf_id: conf_id
              });
            }else{
              _inviteOutboundCall(data.username,data.content.to);
            }   
            
          });

        }else{
          if(calleeClient){
            callerClient.socket.emit('webrtc',{
              type: "ringing",
              number: calleeClient.number
            });

            calleeClient.callreq_id = callerClient.callreq_id;
            callRequests[callerClient.callreq_id].callee = calleeClient;

            calleeClient.socket.emit('webrtc',{
              type: "createRTCoffer",
              inComingNumber: data.username,
              callDirection: 'inbound',
              conf_id: callerClient.conf_id
            });
          }else{
            _inviteOutboundCall(data.username,data.content.to);
          }
          
        }
        break;
      case 'answerInvite':
        var client = clients[data.username];
        var req = callRequests[client.callreq_id];

        if(!client.inConference){
          xmsManager.createConference({
            type: "audiovideo",
            max_p: 9,
            reserve: 0,
            layout: 0,
            caption: "yes"
          },function(conf_id){
            client.conf_id = conf_id;
            conversations[conf_id] = _createConversation(conf_id);

            xmsManager.joinConference(client.local_identifier,conf_id,{
              caption: "webrtc: " + data.username,
              region: 0,
              audio: "sendrecv",
              video: "sendrecv"
            },function(connected){
              console.log(data.username + ' joined conference : ' + connected);
              client.inConference = true;
              conversations[conf_id].inboundContacts.push(data.username);
              socket.join(conf_id.toString());
            });
            
            xmsManager.joinConference(req.caller.remote_identifier,conf_id,{
              caption: "sip: " + unq(req.caller.number),
              region: 0,
              audio: "sendrecv",
              video: "inactive"
            },function(connected){
              console.log(req.caller.number + ' joined conference : ' + connected);
              req.caller.conf_id = conf_id;
              conversations[conf_id].outboundContacts.push(req.caller.number);
              callRequests[client.callreq_id].end = true;
            });

          });
        }else{

          xmsManager.joinConference(req.caller.remote_identifier,client.conf_id,{
            caption: "sip: " + unq(req.caller.number),
            region: 0,
            audio: "sendrecv",
            video: "inactive"
          },function(connected){
            console.log(req.caller.number + ' joined conference : ' + connected);
            req.caller.conf_id = client.conf_id;
            conversations[client.conf_id].outboundContacts.push(req.caller.number);
            callRequests[client.callreq_id].end = true;
          });

        }
        break;
      default:
        break;
    }
  });

  socket.on('webrtc', function (data) {
    log('Got webrtc message:', data);
    
    switch(data.type){
      case 'answerInvite':
        var client = clients[data.username];

        xmsManager.joinConference(client.local_identifier,data.conf_id,{
          caption: "webrtc: " + data.username,
          region: 0,
          audio: "sendrecv",
          video: "sendrecv"
        },function(connected){
          console.log(data.username + ' joined conference : ' + connected);
          client.inConference = true;
          client.conf_id = data.conf_id;
          conversations[data.conf_id].inboundContacts.push(data.username);
          socket.join(data.conf_id.toString());
          socket.broadcast.to(data.conf_id.toString()).emit('webrtc',{
            type: 'join conference',
            colleague: client.username,
            conf_id: data.conf_id
          });
          callRequests[client.callreq_id].end = true;
        });
        break;
      case 'answer':
      /*
        clients[data.username].role = 'callee';
        var call = clients[data.username];
        
        if(call.endIceCandidate){
          xmsManager.updateLocalSDP(data.content.sdp,call,function(){
            
            xmsManager.joinXMSCall(call,function(rs){
              console.log("join call response: \n" + rs);

              gw.sendAnswer(data.username,
                call.sipInviteRequest,
                call.remote_xmsSDP,
                function(){
                  console.log('200 ok answer sent');
                });

            });
          });
        }
      */
        break;
      case 'offer':
        var client = clients[data.username];

        if(!data.content.self){
          var id = uuid.v1();
          client.callreq_id = id;

          callRequests[id] = _createCallRequest(id);
          callRequests[id].caller = client;
          
        }else{

          /*
          gw.sendAnswer(data.username,
            clients[data.username].sipInviteRequest,
            clients[data.username].remote_xmsSDP,
            function(){
              console.log('200 ok answer sent');
          });
          */
        }
        
        if(client.inConference){
          socket.emit('webrtc',{
            type: "answer",
            self: data.content.self
          });
        }
        
        break;
      case 'register':
        clients[data.username] = {};
        _resetClient(data.username,data.host,socket,delivery);

        socket.join(data.host);

        var colleagues = _und.map(clients,function(client,key){
          if(client.host == data.host && key != data.username){
            return {
              name: client.username,
              number: client.number,
              online: true
            };
          }
        });

        colleagues = _und.filter(colleagues,function(client){
          return client != null;
        });

        socket.emit('webrtc',{
          type: 'register',
          msg: 'success',
          colleagues: colleagues
        });
        
        socket.broadcast.to(data.host).emit('webrtc', {
          type: 'online',
          user: {
            name: data.username,
            number: clients[data.username].number,
            online: true
          }
        });

        break;
      case 'endCandidate':
        var client = clients[data.username];
        client.endIceCandidate = true;
        
        var role = callRequests[client.callreq_id].caller.number == data.username ? 'caller' : 'callee';

        console.log('webrtc:endCandidate: ' + role + ' sdp: ' + data.content.sdp);

        if(client.local_xmsSDP == '' || client.local_identifier == ''){
            xmsManager.createXMSCall({
            callType: 'webrtc',
            sdp: data.content.sdp
          },function(xmsSdp,id){
            client.local_xmsSDP = xmsSdp;
            client.local_identifier = id;

            socket.emit('webrtc',{
              type: "answer",
              sdp: xmsSdp,
              self: data.content.self
            });
          });
        }else{
          xmsManager.updateLocalSDP(data.content.sdp,client,function(sdp){
            client.local_xmsSDP = sdp;
            socket.emit('webrtc',{
              type: "answer",
              sdp: sdp,
              self: data.content.self
            });
          });
        }

        break;
      case 'candidate':
        
        break;
      case 'hangup':
        
        try{
          var client = clients[data.username];
          var numberClient = clients[data.pairNumber] ? clients[data.pairNumber] : sipClients[data.pairNumber];

          if(!numberClient){

            gw.sendCancel(data.username,data.pairNumber,function(){
              console.log(data.username + 'cancel the call');

              callRequests[client.call_req].end = true;

            });

            var conf = conversations[client.conf_id];

            if(!client.inConference || conf.inboundContacts + conf.outboundContacts <= 1){

              xmsManager.deleteXMSCall(client.local_identifier,function(rs){
                if(rs.statusCode === 204){
                  console.log('hangup: ' + client.username);
                  client.socket.emit('webrtc',{ type: 'bye'});
                  
                  _resetClient(client.username,client.host,client.socket,client.delivery);
                  
                }
              });

            }

          }else{

            if(numberClient.type === 'webrtc' && data.status === 'on'){
              var conf = conversations[client.conf_id];
              var i = conf.inboundContacts.indexOf(client.username);
              if(i != -1) {
                conf.inboundContacts.splice(i, 1);
              }
              //conf.inboundContacts.pop(client.username);

              xmsManager.deleteXMSCall(client.local_identifier,function(rs){
                if(rs.statusCode === 204){
                  console.log('hangup: ' + client.username);
                  client.socket.emit('webrtc',{ type: 'bye'});

                  try{
                    if(conf.inboundContacts.length + conf.outboundContacts.length > 1){
                      socket.broadcast.to(client.conf_id).emit('webrtc',{
                        type: 'forward',
                        number: client.number,
                        newNumber: conf.outboundContacts.length != 0 ? conf.outboundContacts[0] : conf.inboundContacts[0],
                        webrtcOnly: conf.outboundContacts.length == 0 ? true : false
                      });
                    }
                  }catch(e){
                    console.log('RUNTIME ERROR:webrtc:hangup:forward: ', e);
                  }
                  
                  _resetClient(client.username,client.host,client.socket,client.delivery);
                  
                }
              });

              if(conf.outboundContacts.length == 0 && conf.inboundContacts.length == 1){
                xmsManager.deleteXMSCall(numberClient.local_identifier,function(rs){
                  if(rs.statusCode === 204){
                    console.log('hangup to delete: ' + numberClient.username);
                    numberClient.socket.emit('webrtc',{ 
                      type: 'bye',
                      number: client.number
                    });
                    _resetClient(numberClient.username,numberClient.host,numberClient.socket,numberClient.delivery);
                    var i = conf.inboundContacts.indexOf(numberClient.username);
                    if(i != -1) {
                      conf.inboundContacts.splice(i, 1);
                    }
                    //conf.inboundContacts.pop(numberClient.username);
                    xmsManager.deleteXMSConference(conf.id,function(rs){
                      if(rs.statusCode === 204){
                        console.log('webrtc:hangup:conference resource: ' + conf.id + ' delete success.');
                        delete conf;
                      }
                    });
                  }
                });
              }else if(conf.outboundContacts.length == 1 && conf.inboundContacts.length == 0){
                var sipNo = conf.outboundContacts[0];
                var sipClient = sipClients[sipNo];

                xmsManager.deleteXMSCall(sipClient.remote_identifier,function(rs){
                  if(rs.statusCode === 204){
                    var i = conf.outboundContacts.indexOf(sipClient.number);
                    if(i != -1) {
                      conf.outboundContacts.splice(i, 1);
                    }
                    //conf.outboundContacts.pop(sipClient.number);

                    var call_req = _und.find(callRequests,function(q){//TODO: first one match bug
                      if(q.caller.type == 'webrtc'){
                        return q.callee.number == sipClient.number;
                      }else{
                        return q.caller.number == sipClient.number;
                      }
                    });

                    var pair = call_req.caller.type == 'webrtc' ? call_req.caller : call_req.callee;

                    gw.sendBye(pair.username,function(){
                      console.log('bye to number: ' + sipClient.number);
                    });

                    xmsManager.deleteXMSConference(conf.id,function(rs){
                      if(rs.statusCode === 204){
                        console.log('webrtc:hangup:conference resource: ' + conf.id + ' delete success.');
                        delete conf;
                      }
                    });
                  }
                });
              }

            }else if(numberClient.type === 'webrtc' && data.status === 'off'){
              console.log('busy: ' + client.username);

              var conf = conversations[numberClient.conf_id];

              numberClient.socket.emit('webrtc',{ 
                type: 'busy',
                source: client.username
              });

              if(conf.outboundContacts.length == 0 && conf.inboundContacts.length == 1){
                xmsManager.deleteXMSCall(numberClient.local_identifier,function(rs){
                  if(rs.statusCode === 204){
                    console.log('busy to delete: ' + numberClient.username);
                    numberClient.socket.emit('webrtc',{ type: 'bye'});
                    _resetClient(numberClient.username,numberClient.host,numberClient.socket,numberClient.delivery);
                    var i = conf.inboundContacts.indexOf(numberClient.username);
                    if(i != -1) {
                      conf.inboundContacts.splice(i, 1);
                    }
                    //conf.inboundContacts.pop(numberClient.username);

                    xmsManager.deleteXMSConference(conf.id,function(rs){
                      if(rs.statusCode === 204){
                        console.log('webrtc:hangup:conference resource: ' + conf.id + ' delete success.');
                        delete conf;
                      }
                    });
                  }
                });
              }

            }else if(numberClient.type === 'sip' && data.status === 'on'){
              var conf = conversations[client.conf_id];
              var i = conf.inboundContacts.indexOf(client.username);
              if(i != -1) {
                conf.inboundContacts.splice(i, 1);
              }
              //conf.inboundContacts.pop(client.username);

              xmsManager.deleteXMSCall(client.local_identifier,function(rs){
                if(rs.statusCode === 204){
                  console.log('hangup: ' + client.username);
                  client.socket.emit('webrtc',{ type: 'bye'});

                  if(conf.inboundContacts.length + conf.outboundContacts.length > 1){
                    socket.broadcast.to(client.conf_id).emit('webrtc',{
                      type: 'forward',
                      number: client.number,
                      newNumber: conf.outboundContacts.length != 0 ? conf.outboundContacts[0] : conf.inboundContacts[0],
                      webrtcOnly: conf.outboundContacts.length == 0 ? true : false
                    });
                  }

                  if(conf.inboundContacts.length == 0){
                    xmsManager.deleteXMSCall(numberClient.remote_identifier,function(rs){
                      if(rs.statusCode === 204){
                        var i = conf.outboundContacts.indexOf(numberClient.number);
                        if(i != -1) {
                          conf.outboundContacts.splice(i, 1);
                        }
                        //conf.outboundContacts.pop(numberClient.number);

                        var call_req = _und.find(callRequests,function(q){//TODO: first one match bug
                          if(q.caller.type == 'webrtc'){
                            return q.callee.number == numberClient.number;
                          }else{
                            return q.caller.number == numberClient.number;
                          }
                        });

                        var pair = call_req.caller.type == 'webrtc' ? call_req.caller : call_req.callee;

                        gw.sendBye(pair.username,function(){
                          console.log('bye to number: ' + numberClient.number);
                        });

                        xmsManager.deleteXMSConference(conf.id,function(rs){
                          if(rs.statusCode === 204){
                            console.log('sip:hangup:conference resource: ' + conf.id + ' delete success.');
                            delete conf;
                          }
                        });

                      }
                      
                    });
                  }

                  _resetClient(client.username,client.host,client.socket,client.delivery);

                }
              });

            }else if(numberClient.type === 'sip' && data.status === 'off'){

              gw.sendBye(client.username,function(){
                console.log('bye to number: ' + numberClient.number);
              });

            }

          }

        }catch(e){
          console.log('RUNTIME ERROR:sip:hangup: ', e);
        }

        break;
      default:
        
        break;
    }
  });

  socket.on('message',function(data){

    log('Got text message:', data);

    var client = clients[data.source];

    try{

      if(client.conf_id && data.type === 'IM'){
        socket.broadcast.to(client.conf_id.toString()).emit('message',data);

        var conference = conversations[client.conf_id];
        if(conference.outboundContacts.length != 0){
          _und.each(conference.outboundContacts,function(sipNumber,key){
            data.toNumber = sipNumber;
            _sendSMS(data,function(result){
              client.socket.emit('message',{
                type: 'IM Report',
                status: result,
                content: data.content,
                toNumber: sipNumber
              });
            });
          });
        }

      }else if(data.type === 'SMS'){
        _sendSMS(data,function(result){
          client.socket.emit('message',{
            type: 'SMS Report',
            status: result,
            content: data.content,
            toNumber: data.toNumber,
            comment: data.comment
          });
        });
      }

    }catch(e){
      console.log('RUNTIME ERROR:message: ', e);
    }

  });

  socket.on('disconnect', function() {

    var lostClient = _und.find(clients,function(client,key){
      return client.socket.id == socket.id;
    });

    if(lostClient){

      var conf = lostClient.conf_id ? conversations[lostClient.conf_id] : undefined;
      if(conf){
        var i = conf.inboundContacts.indexOf(lostClient.username);
        if(i != -1) {
          conf.inboundContacts.splice(i, 1);
        }
        //conf.inboundContacts.pop(lostClient.username);
      }

      if(lostClient.local_identifier){
        xmsManager.deleteXMSCall(lostClient.local_identifier,function(rs){
          if(rs.statusCode === 204){
            console.log('disconnect: ' + lostClient.username);
          }
        });
      }

      delete clients[lostClient.username];

      socket.broadcast.to(lostClient.host).emit('webrtc',{
        type: 'disconnect',
        user: {
          name: lostClient.username,
          number: lostClient.number,
          online: false
        }
      });

      gw.unregister(lostClient.username);
    }

  });

  delivery.on('receive.success',function(file){

    var sendingClient = _und.find(clients,function(client,key){
      return client.socket.id == socket.id;
    });

    fs.writeFile(file.name,file.buffer, function(err){
      if(err){
        console.log('File could not be saved.');
      }else{
        console.log('File saved.');
        _und.each(clients,function(client,key){
          //if(client.conf_id == sendingClient.conf_id && client.username != sendingClient.username){
          if(sendingClient.conf_id && client.conf_id == sendingClient.conf_id && client.username != sendingClient.username){

            client.socket.emit('message',{
              content: 'Sharing file: ' + file.name + ' ...',
              source: sendingClient.username,
              number: sendingClient.number,
              action: false
            });

            client.delivery.send({
              name: file.name,
              path : './' + file.name
            });

          }
        });

        fs.unlink('./' + file.name);
      };
    });
  });

}
\end{lstlisting}


\chapter{Appendix C}

\section{WebRTC in Dart} \label{research:dart_webrtcctrl}

\begin{lstlisting}[caption={WebRTCCtrl in Dart application client},label={code:dart_webrtcctrl}]
library webRTCCtrl;

import 'package:angular/angular.dart';
import 'dart:html';
import 'package:webrtcDemo/speaker/speack_client.dart';

@NgController(
  selector : '[webrtc-ctrl]',
  publishAs : 'ctrl'
)

class WebRTCCtrl {

  static const String SERVER_URL = "ws://127.0.0.1:3001";

  String websocketUrl = SERVER_URL;

  WebRTCCtrl() {
    _initConnection();
  }

  void _initConnection(){
    var speaker = new SpeakerClient(websocketUrl, room: 'room');

    speaker.createStream(audio: true, video: true ).then((stream) {
      var video = new VideoElement()
        ..autoplay = true
        ..src = Url.createObjectUrl(stream);

      document.body.append(video);
    });

    speaker.onAdd.listen((message) {
      var video = new VideoElement()
        ..id = 'remote${message['id']}'
        ..autoplay = true
        ..src = Url.createObjectUrl(message['stream']);

      document.body.append(video);
    });

    speaker.onLeave.listen((message) {
      document.query('#remote${message['id']}').remove();
    });
  }
}
\end{lstlisting}

\chapter{Appendix D}

\section{AngularJs Files Structure} \label{code:angularjs_structure}

\begin{figure}
	\centering
    	\includegraphics[height=0.45\textheight,natwidth=610,natheight=642]{figs/angularjs_structure.png}
  	\caption{Prototype Application AngularJs Files}
  	\label{fig:angularjs_structure}
\end{figure}

\end{appendices}